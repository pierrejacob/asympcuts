#### Data ####
## generated by inst/toy_example/toy_example_v2_generate_data.R
load("inst/toy_example/toy_example_data.RData")
# SCENARIO <- 1  # choose scenario 1 (rho = 0, sigma =1 ) or 2 (rho = 0.5, sigma =2)
if (SCENARIO == 1){
  attach(data_scenario1)
}
if (SCENARIO == 2){
  attach(data_scenario2)
}
#### Log-posterior density function in both stages and point estimation ####
## first target
target1 <- list(dimension = 1, density = function(theta1){
  return(sapply(1:dim(theta1)[1], function(ichain) ll1(theta1[ichain,1], z) + lp1(theta1[ichain,1])))
})

# get second stage target given theta1
get_target2 <- function(theta1){
  ## joint model's posterior for theta_1 and theta_2
  return(list(dimension = 1, density = function(theta2){
    return(sapply(1:dim(theta2)[1], function(ichain)  ll2(theta1, theta2, x, y) + lp2(theta2)))
  }))
}

##### 2SMAP #####
#### Cut Laplace approximation ####
laplace_cut_res <- laplace_cut(logposterior1 = function(theta1) ll1(theta1, z) + lp1(theta1),
                               logposterior2 = function(theta1, theta2) ll2(theta1, theta2, x, y) + lp2(theta2),
                               init_theta1 = 0,
                               init_theta2 = 0)
twostage_map <- laplace_cut_res$thetahat
twostage_map[1]
# nearly identical to
mean(z)
# and second stage MAP
twostage_map[2]
sum(x*y)/sum(x^2) - sum(x) / (sum(x^2)) * twostage_map[1]



#### Cut Bayesian inference via RWMRTH ####

##### Stage 1 #####

## tuning parameters for rwmrth
tuning_parameters <- list()
tuning_parameters$cov_proposal <- diag(1)
tuning_parameters$niterations <- 20000
tuning_parameters$nchains <- 4
tuning_parameters$adaptation <- 1000
tuning_parameters$rinit <- function(nchains){
  matrix(rnorm(nchains*target1$dimension, 0, 1), ncol = target1$dimension)
}
## initialization
current_chains <- tuning_parameters$rinit(tuning_parameters$nchains)
## MCMC run
rwmrth_stage1_res <- rwmrth(target1, tuning_parameters)
burnin <- tuning_parameters$niterations/5
## trace plot of first column of each matrix in rwmrth_res_joint$chains
# plot(rwmrth_stage1_res$chains[[1]][,1], type ='l', ylim = c(-2, +2))
# for (ichain in 2:tuning_parameters$nchains) lines(rwmrth_stage1_res$chains[[ichain]][,1])
# # zoom in
# plot(rwmrth_stage1_res$chains[[1]][burnin:tuning_parameters$niterations,1], type ='l', ylim = c(-.1, .1), ylab = expression(theta[1]))
# for (ichain in 2:tuning_parameters$nchains) lines(rwmrth_stage1_res$chains[[ichain]][burnin:tuning_parameters$niterations,1])
#
all_samples1 <- foreach(ichain = 1:tuning_parameters$nchains, .combine = rbind) %do% {
  rwmrth_stage1_res$chains[[ichain]][(burnin+1):tuning_parameters$niterations,,drop=F]
}

# Compare to Laplace approximation
# Compute Hessian at 1st-stage MAP
minusHlogpost1 <- -hessian(func = function(theta1) ll1(theta1,z) + lp1(theta1), twostage_map[1])
cov_laplace1 <- solve(minusHlogpost1)
cov_laplace1[1,1]
var(all_samples1[,1])
## very accurate

##### Stage 2 #####
# select nsamples equispaced draws in all_samples1
nsamples1 <- 5000
# stop if nsamples1 < nrow(all_samples1)
if (nsamples1 > nrow(all_samples1)) {
  stop("nsamples1 is larger than the number of available samples from stage 1")
}
selected_indices <- round(seq(1, nrow(all_samples1), length.out = nsamples1))
theta1_samples_for_stage2 <- all_samples1[selected_indices, , drop=F]
## register parallel backend
n_cores <- detectCores() - 1
cl <- makeCluster(n_cores)
registerDoParallel(cl)
clusterExport(cl, "SCENARIO")
clusterEvalQ(cl, {
  library(asympcuts)
  load("inst/toy_example/toy_example_data.RData")
  if (SCENARIO == 1){
    attach(data_scenario1)
  }
  if (SCENARIO == 2){
    attach(data_scenario2)
  }
})


# foreach loop, loading functions and package in memory
theta2_samples <- foreach(isample1 = 1:nsamples1, .combine = rbind) %dorng% {
  theta1_sample <- theta1_samples_for_stage2[isample1, 1]
  target2 <- get_target2(theta1_sample)
  # tuning parameters for rwmrth
  tuning_parameters_stage2 <- list()
  tuning_parameters_stage2$cov_proposal <- diag(1)
  tuning_parameters_stage2$niterations <- 500
  tuning_parameters_stage2$nchains <- 1
  tuning_parameters_stage2$adaptation <- 200
  tuning_parameters_stage2$rinit <- function(nchains){
    matrix(rnorm(nchains*target2$dimension, 0, 1), ncol = target2$dimension)
  }
  rwmrth_stage2_res <- rwmrth(target2, tuning_parameters_stage2)
  # collect last sample
  tail(rwmrth_stage2_res$chains[[1]], n = 1)[1]
}
# end cluster
stopCluster(cl)

cut_samples <- cbind(theta1_samples_for_stage2, as.numeric(theta2_samples))

samples_laplace <- fast_rmvnorm(1e5, twostage_map, laplace_cut_res$asympvar)
#### Plot Ellipses for the two stage approach ####

# plot 95% credible region associated with all_samples using stat_ellipse
# df_samples <- data.frame(theta1 = cut_samples[,1], theta2 = cut_samples[,2])
# ggplot(df_samples, aes(x = theta1, y = theta2)) + theme_bw()  +
#   stat_ellipse(level = 0.95, color = 'blue', type = 'norm', linewidth = 2) +
#   stat_ellipse(level = 0.95, type = 'norm', mapping = aes(x = theta1, y = theta2),
#                data = data.frame(theta1 = samples_laplace[,1], theta2 = samples_laplace[,2]),
#                inherit.aes = FALSE,
#                color = 'red', linetype = 2, linewidth = 2) +
#   xlab(expression(theta[1])) + ylab(expression(theta[2])) +
#   geom_point(data = data.frame(theta1 = twostage_map[1], theta2 = twostage_map[2]),
#                  aes(x = theta1, y = theta2),
#                  color ='black', pch = 19, size = 3) +
#   ggtitle('95% credible regions: Cut Posterior (blue) vs Cut-Laplace (red)')

#### Using PBMI ####

pbmi_nsamples <- 5000
n_cores <- detectCores() - 1
cl <- makeCluster(n_cores)
registerDoParallel(cl)
clusterExport(cl, "SCENARIO")
clusterEvalQ(cl, {
  library(asympcuts)
  load("inst/toy_example/toy_example_data.RData")
  attach(if (SCENARIO == 1) data_scenario1 else data_scenario2)
})
pbmi_samples <- foreach (isample = 1:pbmi_nsamples, .combine = rbind) %dorng% {
  w_0 <- 1
  w1 <- rexp(n, rate = 1)
  f_1 <- function(theta1) -sum(w1 * dnorm(z, mean = theta1, sd = 1, log = TRUE)) - w_0 * lp1(theta1)
  optim_1 <- tryCatch(optim(par = 0, fn = f_1, method = 'BFGS'), error = function(e)  return(list(error = TRUE)))
  pbmi_theta1 <- optim_1$par
  ## refresh weights
  # w1 <- rexp(n, rate = 1)
  f_2 <- function(theta2) -sum(w1 * dnorm(y, mean = pbmi_theta1 + theta2 * x, sd = 1, log = TRUE)) - w_0 * lp2(theta2)
  optim_2 <- tryCatch(optim(par = 0, fn = f_2, method = 'BFGS'), error = function(e)  return(list(error = TRUE)))
  pbmi_theta2 <- optim_2$par
  c(pbmi_theta1, pbmi_theta2)
}
clusterEvalQ(cl, {
  print(SCENARIO)
  mean(y)
})

# end cluster
stopCluster(cl)

cov(pbmi_samples)
cov(cut_samples)
cov(samples_laplace)

colMeans(pbmi_samples)
twostage_map


## plot 95% credible region associated with all_samples using stat_ellipse
# df_samples <- data.frame(theta1 = cut_samples[,1], theta2 = cut_samples[,2])
# ggplot(df_samples, aes(x = theta1, y = theta2)) + theme_bw()  +
#   # geom_point(alpha = 0.3) +
#   stat_ellipse(level = 0.95, color = 'blue', type = 'norm', linewidth = 2) +
#   stat_ellipse(level = 0.95, type = 'norm', mapping = aes(x = theta1, y = theta2),
#                data = data.frame(theta1 = pbmi_samples[,1], theta2 = pbmi_samples[,2]),
#                inherit.aes = FALSE,
#                color = 'green', linetype = 2, linewidth = 2) +
#   stat_ellipse(level = 0.95, type = 'norm', mapping = aes(x = theta1, y = theta2),
#                data = data.frame(theta1 = samples_laplace[,1], theta2 = samples_laplace[,2]),
#                inherit.aes = FALSE,
#                color = 'red', linetype = 2, linewidth = 2) +
#   xlab(expression(theta[1])) + ylab(expression(theta[2])) +
#   ggtitle('95% credible regions: Cut Posterior (blue) vs PBMI (green) vs Cut-Laplace (red)')


laplace_cut_var <- laplace_cut_res$asympvar
save(cut_samples, pbmi_samples, twostage_map, laplace_cut_var, file = paste0('inst/toy_example/toy_example_v2_twostage_scenario', SCENARIO, '.RData'))



